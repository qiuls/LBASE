<?phpnamespace Base\Queue;use Base\Facade\Log;use Illuminate\Queue\Events\WorkerStopping;use Illuminate\Queue\WorkerOptions;use Base\Model\Queue\FailedJob;/** * 该任务负责处理任务 * Class Execute * @package Base\Queue */class Execute{    protected $queue_push = null;    protected $listen_microseconds = null;    protected $error_num = null;    protected $timeout = 3; //超时时间 执行的超时时间    protected $restart_key = 'php:Queue:restart';    protected $stop_key = 'php:Queue:stop';    protected $is_work = false;    protected $is_listen = false;    public function __construct(Push $push)    {        ignore_user_abort(true);        set_time_limit(0);        $this->queue_push = $push;        $this->listen_microseconds = 2000000;//2000毫秒 2秒        $this->error_num = 3;    }    public function work(){        $this->is_work = true;        if(!$this->supportsAsyncSignals()){            Log::queueLog('note_erorr not load pcntl');        }        $this->listenForSignals();        $this->handle();    }    public function failWork($queue = 'fail'){        $fail_model = FailedJob::query()->findAll();        $list_key = $this->queue_push->getQueueKey($queue);        $hash_key = $this->queue_push->getQueueHashKey($queue);        $fail_list = $fail_model->toArray();        try {            foreach ($fail_list as $fail) {                $fail_data = json_decode($fail['param_data'], true);                if (!$fail_data) {                    continue;                }                $job_key = $fail_data['id'] ?? $this->queue_push->getForm62PushId();                $fail_data['error'] = 0;                $this->resetPush($list_key, $job_key,$hash_key, $fail_data);                FailedJob::query()->where('id', $fail_data['id'])->delete();            }            $this->handle($queue);        } catch (\Exception $exception){                //失败处理                $redis->hdel($hash_key,$job_key);                $h_value_array['error']= 4;                $this->errorTry($h_value_array,$job_key,$exception->getMessage(),$queue);            }    }    /**     * 处理当前任务 处理完后自动退出     */    protected function handle($queue = 'default'){        $redis = $this->queue_push->getRedisStore();        $list_key = $this->queue_push->getQueueKey($queue);        $hash_key = $this->queue_push->getQueueHashKey($queue);        //重启或者停止        $this->checkCmdStatus();        try{            while ($num = $redis->llen($list_key)){                //重启或者停止                $this->checkCmdStatus();                //弹出队列任务                $job_key = $redis->rpop($list_key);                if(!$job_key){                    break;                }                $job_value = $redis->hget($hash_key,$job_key);                if(!$job_value){                    continue;                }                //处理方法                $job_value_array = json_decode($job_value,true);                if(!$job_value_array){                    continue;                }                $this->registerTimeoutHandler($job_value_array);                $class_ob = \Ioc::getInstance($job_value_array['class']);                $class_ob->setData($job_value_array['param']);                $res = $class_ob->handle();                if($res){                    Log::queueLog("Queue exec ".$job_value .' success');                    $redis->hdel($hash_key,$job_key);                    continue;                }                Log::queueLog("Queue exec ".$job_value .' error');                //失败处理                $this->errorTry($job_value_array,$job_key,'',$queue);            }        }catch (\Exception $exception){            //失败处理            $redis->hdel($hash_key,$job_key);            $job_value_array['error']= 4;            $this->errorTry($job_value_array,$h_key,$exception->getMessage(),$queue);        }    }    //执行失败处理    public function errorTry($job_value_array,$h_key,$exception_message = null,$queue = 'default',$connection = 'redis'){//        Log::queueLog('__errorTry__ $h_key'.$h_key);//        Log::queueLog('__errorTry__'.json_encode($job_value_array));        $list_key = $this->queue_push->getQueueKey($queue);        $hash_key = $this->queue_push->getQueueHashKey($queue);        $redis = $this->queue_push->getRedisStore();        if($job_value_array['error'] > $this->error_num){            //写入db            $this->addFailDbRow($job_value_array,$exception_message,$queue = 'default',$connection = 'redis');            $redis->hdel($hash_key,$h_key);            return true;        }        //重新递交队列        $job_value_array['error']++;        $this->resetPush($list_key,$h_key,$hash_key,$job_value_array);    }    protected function resetPush($list_key,$h_key,$hash_key,$h_value_array){        $redis = $this->queue_push->getRedisStore();        $res = $redis->hset($hash_key,$h_key,json_encode($h_value_array));        $redis->lpush($list_key,$h_key);        return true;    }    protected function addFailDbRow($data,$exception = '',$queue = 'default',$connection = 'redis'){        $fail_model = new FailedJob;        $fail_model->connection = $connection;        $fail_model->queue = $queue;        $fail_model->param_data = json_encode($data);        $fail_model->exception = $exception;        $fail_model->failed_at = date('Y-m-d H:i:s');        return $fail_model->save();    }    //监听处理    public function handleListen(){        $this->is_listen = true;        $redis = $this->queue_push->getRedisStore();        $s_time = time();        while (true){            $this->handle();            //心跳             usleep($this->listen_microseconds);             if(env('app.env') != 'live'){                 Log::queueLog('Heartbeat');             }        }    }    public function getRestartKey($def = 'default'){        return $this->restart_key.$def;    }    public function getStopKey($def = 'default'){        return $this->stop_key.$def;    }    //检查状态 是否重启或者关闭    public function checkCmdStatus(){        $redis = $this->queue_push->getRedisStore();        $resrart_key = $this->getRestartKey();        if($redis->exists($resrart_key)){            $redis->del($resrart_key);            $this->reload();        }        $stop_key = $this->getStopKey();        if($redis->exists($stop_key)){            Log::message('stop_Queue');            $redis->del($stop_key);            $this->kill();        }        return false;    }    protected function supportsAsyncSignals()    {        return extension_loaded('pcntl');    }    protected function kill($status = 0)    {        if($status != 0){            $redis = $this->queue_push->getRedisStore();            $stop_key = $this->getStopKey();            $redis->set($stop_key,time());            return true;        }        if ($this->supportsAsyncSignals()) {            posix_kill(getmypid(), SIGKILL);        }        Log::queueLog('状态为 '.$status);        exit($status);    }    //需要通过第三方软件启动 重新加载框架    protected function reload($status = 0){        exit($status);    }    /**     * 监听信号     */    protected function listenForSignals()    {        if($this->supportsAsyncSignals()){            pcntl_async_signals(true);            pcntl_signal(SIGTERM, function () {                $this->kill(15);            });            pcntl_signal(SIGUSR2, function () {                $this->kill(12);            });            pcntl_signal(SIGCONT, function () {                $this->kill(18);            });        }    }    protected function registerTimeoutHandler($job_data)    {         //设置定时器 需要靠supervisor 启动        if($this->supportsAsyncSignals()){            pcntl_signal(SIGALRM, function () use ($job_data) {                if ($job_data) {                    $this->errorTry($job_data,$job_data['id']);                }                Log::queueLog('time out'.$job_data);                if($this->is_listen){                    $this->handleListen();                    return;                }                if($this->is_work){                    $this->handle();                }                $this->kill();            });            pcntl_alarm(                max($this->timeout, 0)            );        }    }}